'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function createMetadata(attribute) {
    return {
        text: attribute['#text'],
        itemUid: attribute["data-sys-entry-uid"] || attribute["data-sys-asset-uid"],
        itemType: attribute.type,
        styleType: attribute["sys-style-type"],
        attributes: attribute,
        contentTypeUid: attribute["data-sys-content-type-uid"],
    };
}
function nodeToMetadata(attribute, textNode) {
    return {
        text: textNode.text,
        itemUid: attribute["entry-uid"] || attribute["asset-uid"],
        itemType: attribute.type,
        styleType: attribute["display-type"],
        attributes: attribute,
        contentTypeUid: attribute["content-type-uid"],
    };
}
function attributeToString(attributes) {
    var result = '';
    var _loop_1 = function (key) {
        if (Object.prototype.hasOwnProperty.call(attributes, key)) {
            var element = attributes[key];
            if (element instanceof Array) {
                var elementString_1 = '';
                var isFirst_1 = true;
                element.forEach(function (value) {
                    if (isFirst_1) {
                        elementString_1 += "".concat(value);
                        isFirst_1 = false;
                    }
                    else {
                        elementString_1 += ", ".concat(value);
                    }
                });
                element = elementString_1;
            }
            else if (typeof element === 'object') {
                var elementString = '';
                for (var elementKey in element) {
                    if (Object.prototype.hasOwnProperty.call(element, elementKey)) {
                        var value = element[elementKey];
                        elementString += "".concat(elementKey, ":").concat(value, "; ");
                    }
                }
                element = elementString;
            }
            result += " ".concat(key, "=\"").concat(element, "\"");
        }
    };
    for (var key in attributes) {
        _loop_1(key);
    }
    return result;
}

var StyleType;
(function (StyleType) {
    StyleType["BLOCK"] = "block";
    StyleType["INLINE"] = "inline";
    StyleType["LINK"] = "link";
    StyleType["DISPLAY"] = "display";
    StyleType["DOWNLOAD"] = "download";
})(StyleType || (StyleType = {}));
var StyleType$1 = StyleType;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function elementToJson(element) {
    var obj = {};
    for (var i = 0; i < element.attributes.length; i++) {
        obj[element.attributes.item(i).name] = element.attributes.item(i).value;
    }
    element.childNodes.forEach(function (chileNode) {
        var node = (chileNode);
        obj = __assign(__assign({}, obj), parseElement(node));
    });
    return obj;
}
function parseElement(node) {
    var obj = {};
    if (node.nodeType === 3) {
        obj['#text'] = node.textContent;
    }
    else if (node.nodeType === 1) {
        obj[node.nodeName.toLowerCase()] = elementToJson(node);
    }
    return obj;
}

var frameflag = 'documentfragmentcontainer';
String.prototype.forEachEmbeddedItem = function (callbackfn) {
    var str = "<".concat(frameflag, ">").concat(this.toString(), "</").concat(frameflag, ">");
    var root = (new DOMParser()).parseFromString(str, 'text/html');
    var embeddedEntries = root.querySelectorAll(".embedded-entry");
    embeddedEntries.forEach(function (element) {
        callbackfn(element.outerHTML, createMetadata(elementToJson(element)));
    });
    var embeddedAsset = root.querySelectorAll(".embedded-asset");
    embeddedAsset.forEach(function (element) {
        callbackfn(element.outerHTML, createMetadata(elementToJson(element)));
    });
};

var _a$1;
var defaultOptions = (_a$1 = {},
    _a$1[StyleType$1.BLOCK] = function (item) {
        return "<div><p>".concat(item.title || item.uid, "</p><p>Content type: <span>").concat(item._content_type_uid || (item.system ? item.system.content_type_uid : ''), "</span></p></div>");
    },
    _a$1[StyleType$1.INLINE] = function (item) { return "<span>".concat(item.title || item.uid, "</span>"); },
    _a$1[StyleType$1.LINK] = function (item, metadata) { return "<a href=\"".concat(item.url, "\">").concat(metadata.text || item.title || item.uid || (item.system ? item.system.uid : ''), "</a>"); },
    _a$1[StyleType$1.DISPLAY] = function (item, metadata) { return "<img src=\"".concat(item.url, "\" alt=\"").concat(metadata.attributes.alt || item.title || item.filename || item.uid
        || (item.system ? item.system.uid : ''), "\" />"); },
    _a$1[StyleType$1.DOWNLOAD] = function (item, metadata) { return "<a href=\"".concat(item.url, "\">").concat(metadata.text || item.title || item.uid || (item.system ? item.system.content_type_uid : ''), "</a>"); },
    _a$1);

// This function will find Embedded object present in string
function findEmbeddedEntry(uid, contentTypeUid, embeddeditems) {
    if (embeddeditems === void 0) { embeddeditems = []; }
    return embeddeditems.filter(function (entry) {
        if ((entry.uid && entry.uid === uid && entry._content_type_uid === contentTypeUid) || (entry.system && entry.system.uid === uid && entry.system.content_type_uid === contentTypeUid)) {
            return entry;
        }
    });
}
function findEmbeddedAsset(uid, embeddedAssets) {
    if (embeddedAssets === void 0) { embeddedAssets = []; }
    return embeddedAssets.filter(function (asset) {
        if ((asset.uid && asset.uid === uid) || asset.system && asset.system.uid === uid) {
            return asset;
        }
    });
}
function findGQLEmbeddedItems(metadata, items) {
    if (metadata.itemType === 'entry') {
        return findEmbeddedEntry(metadata.itemUid, metadata.contentTypeUid, items);
    }
    else {
        return findEmbeddedAsset(metadata.itemUid, items);
    }
}
function findEmbeddedItems(object, entry) {
    if (object && object !== undefined && entry && entry !== undefined) {
        if (entry._embedded_items !== undefined) {
            var entryEmbedable = entry;
            var items = Object.values(entryEmbedable._embedded_items || []).reduce(function (accumulator, value) { return accumulator.concat(value); }, []);
            return findGQLEmbeddedItems(object, items);
        }
    }
    return [];
}
function findRenderString(item, metadata, renderOptions) {
    if ((!item && item === undefined) || (!metadata && metadata === undefined)) {
        return '';
    }
    if (renderOptions && renderOptions[metadata.styleType] !== undefined) {
        var renderFunction = renderOptions[metadata.styleType];
        if (metadata.attributes['data-sys-content-type-uid'] !== undefined &&
            typeof renderFunction !== 'function' &&
            renderFunction[metadata.attributes['data-sys-content-type-uid']] !== undefined) {
            return renderFunction[metadata.attributes['data-sys-content-type-uid']](item, metadata);
        }
        else if (metadata.attributes['data-sys-content-type-uid'] !== undefined &&
            typeof renderFunction !== 'function' &&
            renderFunction.$default !== undefined) {
            return renderFunction.$default(item, metadata);
        }
        else if (metadata.contentTypeUid !== undefined &&
            typeof renderFunction !== 'function' &&
            renderFunction[metadata.contentTypeUid] !== undefined) {
            return renderFunction[metadata.contentTypeUid](item, metadata);
        }
        else if (metadata.contentTypeUid !== undefined &&
            typeof renderFunction !== 'function' &&
            renderFunction.$default !== undefined) {
            return renderFunction.$default(item, metadata);
        }
        else if (typeof renderFunction === 'function') {
            return renderFunction(item, metadata);
        }
    }
    var defaultRenderFunction = defaultOptions[metadata.styleType];
    return defaultRenderFunction(item, metadata);
}

function findRenderContent(keyPaths, entry, render) {
    getContent(keyPaths.split("."), entry, render);
}
function getContent(keys, object, render) {
    if (keys) {
        var key = keys[0];
        if (keys.length === 1 && object[key]) {
            object[key] = render(object[key]);
        }
        else if (keys.length > 0) {
            if (object[key]) {
                var newKeys = keys.slice(1);
                if (Array.isArray(object[key])) {
                    // tslint:disable-next-line: prefer-for-of
                    for (var _i = 0, _a = object[key]; _i < _a.length; _i++) {
                        var objKey = _a[_i];
                        getContent(newKeys, objKey, render);
                    }
                }
                else if (typeof object[key] === 'object') {
                    getContent(newKeys, object[key], render);
                }
            }
        }
    }
}

/**
 *
 * @param {EntryEmbedable| EntryEmbedable[]} entry - Objects that contains RTE with embedded objects
 * @param {string[]} paths - Key paths for RTE contents in Entry object
 * @param {RenderOption?} renderOption -  Optional render options to render content
 */
function render(option) {
    function findContent(path, entry) {
        findRenderContent(path, entry, function (content) {
            return renderContent(content, { entry: entry, renderOption: option.renderOption });
        });
    }
    function findAndRender(entry) {
        if (!option.paths || option.paths.length === 0) {
            Object.keys(__assign({}, entry._embedded_items)).forEach(function (path) {
                findContent(path, entry);
            });
        }
        else {
            option.paths.forEach(function (path) {
                findContent(path, entry);
            });
        }
    }
    if (option.entry instanceof Array) {
        option.entry.forEach(function (entry) {
            findAndRender(entry);
        });
    }
    else {
        findAndRender(option.entry);
    }
}
/**
 *
 * @param {string | string[]} content - RTE content to render
 * @param {EntryEmbedable} options.entry - Entry object containing embedded objects
 * @param {RenderOption?} options.renderOption - Optional render options to render content
 */
function renderContent(content, option) {
    // return blank if content not present
    if (!content || content === undefined) {
        return '';
    }
    // render content of type string
    if (typeof content === 'string') {
        var contentToReplace_1 = content;
        content.forEachEmbeddedItem(function (embededObjectTag, object) {
            contentToReplace_1 = findAndReplaceEmbeddedItem(contentToReplace_1, embededObjectTag, object, option);
        });
        return contentToReplace_1;
    }
    // render content of type array of string
    var resultContent = [];
    content.forEach(function (element) {
        resultContent.push(renderContent(element, option));
    });
    return resultContent;
}
function findAndReplaceEmbeddedItem(content, embededObjectTag, metadata, option) {
    var embeddedObjects = findEmbeddedItems(metadata, option.entry);
    var renderString = findRenderString(embeddedObjects[0], metadata, option.renderOption);
    return content.replace(embededObjectTag, renderString);
}

var NodeType;
(function (NodeType) {
    NodeType["DOCUMENT"] = "doc";
    NodeType["PARAGRAPH"] = "p";
    NodeType["LINK"] = "a";
    NodeType["IMAGE"] = "img";
    NodeType["EMBED"] = "embed";
    NodeType["HEADING_1"] = "h1";
    NodeType["HEADING_2"] = "h2";
    NodeType["HEADING_3"] = "h3";
    NodeType["HEADING_4"] = "h4";
    NodeType["HEADING_5"] = "h5";
    NodeType["HEADING_6"] = "h6";
    NodeType["ORDER_LIST"] = "ol";
    NodeType["UNORDER_LIST"] = "ul";
    NodeType["LIST_ITEM"] = "li";
    NodeType["HR"] = "hr";
    NodeType["TABLE"] = "table";
    NodeType["TABLE_HEADER"] = "thead";
    NodeType["TABLE_BODY"] = "tbody";
    NodeType["TABLE_FOOTER"] = "tfoot";
    NodeType["TABLE_ROW"] = "tr";
    NodeType["TABLE_HEAD"] = "th";
    NodeType["TABLE_DATA"] = "td";
    NodeType["BLOCK_QUOTE"] = "blockquote";
    NodeType["CODE"] = "code";
    NodeType["TEXT"] = "text";
    NodeType["REFERENCE"] = "reference";
})(NodeType || (NodeType = {}));
var NodeType$1 = NodeType;

var MarkType;
(function (MarkType) {
    MarkType["BOLD"] = "bold";
    MarkType["ITALIC"] = "italic";
    MarkType["UNDERLINE"] = "underline";
    MarkType["STRIKE_THROUGH"] = "strikethrough";
    MarkType["INLINE_CODE"] = "inlineCode";
    MarkType["SUBSCRIPT"] = "subscript";
    MarkType["SUPERSCRIPT"] = "superscript";
})(MarkType || (MarkType = {}));
var MarkType$1 = MarkType;

var Node = /** @class */ (function () {
    function Node() {
    }
    return Node;
}());

var Document = /** @class */ (function (_super) {
    __extends(Document, _super);
    function Document() {
        var _this = _super.call(this) || this;
        _this.type = NodeType$1.DOCUMENT;
        return _this;
    }
    return Document;
}(Node));

var TextNode = /** @class */ (function (_super) {
    __extends(TextNode, _super);
    function TextNode(text) {
        var _this = _super.call(this) || this;
        _this.text = text;
        return _this;
    }
    return TextNode;
}(Node));

var _a;
var defaultNodeOption = (_a = {},
    _a[NodeType$1.DOCUMENT] = function (node) {
        return "";
    },
    _a[NodeType$1.PARAGRAPH] = function (node, next) {
        return "<p>".concat(next(node.children), "</p>");
    },
    _a[NodeType$1.LINK] = function (node, next) {
        return "<a href=\"".concat(node.attrs.href || node.attrs.url, "\">").concat(next(node.children), "</a>");
    },
    _a[NodeType$1.IMAGE] = function (node, next) {
        return "<img src=\"".concat(node.attrs.src || node.attrs.url, "\" />").concat(next(node.children));
    },
    _a[NodeType$1.EMBED] = function (node, next) {
        return "<iframe src=\"".concat(node.attrs.src || node.attrs.url, "\">").concat(next(node.children), "</iframe>");
    },
    _a[NodeType$1.HEADING_1] = function (node, next) {
        return "<h1>".concat(next(node.children), "</h1>");
    },
    _a[NodeType$1.HEADING_2] = function (node, next) {
        return "<h2>".concat(next(node.children), "</h2>");
    },
    _a[NodeType$1.HEADING_3] = function (node, next) {
        return "<h3>".concat(next(node.children), "</h3>");
    },
    _a[NodeType$1.HEADING_4] = function (node, next) {
        return "<h4>".concat(next(node.children), "</h4>");
    },
    _a[NodeType$1.HEADING_5] = function (node, next) {
        return "<h5>".concat(next(node.children), "</h5>");
    },
    _a[NodeType$1.HEADING_6] = function (node, next) {
        return "<h6>".concat(next(node.children), "</h6>");
    },
    _a[NodeType$1.ORDER_LIST] = function (node, next) {
        return "<ol>".concat(next(node.children), "</ol>");
    },
    _a[NodeType$1.UNORDER_LIST] = function (node, next) {
        return "<ul>".concat(next(node.children), "</ul>");
    },
    _a[NodeType$1.LIST_ITEM] = function (node, next) {
        return "<li>".concat(next(node.children), "</li>");
    },
    _a[NodeType$1.HR] = function (node, next) {
        return "<hr>";
    },
    _a[NodeType$1.TABLE] = function (node, next) {
        return "<table>".concat(next(node.children), "</table>");
    },
    _a[NodeType$1.TABLE_HEADER] = function (node, next) {
        return "<thead>".concat(next(node.children), "</thead>");
    },
    _a[NodeType$1.TABLE_BODY] = function (node, next) {
        return "<tbody>".concat(next(node.children), "</tbody>");
    },
    _a[NodeType$1.TABLE_FOOTER] = function (node, next) {
        return "<tfoot>".concat(next(node.children), "</tfoot>");
    },
    _a[NodeType$1.TABLE_ROW] = function (node, next) {
        return "<tr>".concat(next(node.children), "</tr>");
    },
    _a[NodeType$1.TABLE_HEAD] = function (node, next) {
        return "<th>".concat(next(node.children), "</th>");
    },
    _a[NodeType$1.TABLE_DATA] = function (node, next) {
        return "<td>".concat(next(node.children), "</td>");
    },
    _a[NodeType$1.BLOCK_QUOTE] = function (node, next) {
        return "<blockquote>".concat(next(node.children), "</blockquote>");
    },
    _a[NodeType$1.CODE] = function (node, next) {
        return "<code>".concat(next(node.children), "</code>");
    },
    _a['reference'] = function (node, next) {
        return "";
    },
    _a['default'] = function (node, next) {
        return next(node.children);
    },
    _a[MarkType$1.BOLD] = function (text) {
        return "<strong>".concat(text, "</strong>");
    },
    _a[MarkType$1.ITALIC] = function (text) {
        return "<em>".concat(text, "</em>");
    },
    _a[MarkType$1.UNDERLINE] = function (text) {
        return "<u>".concat(text, "</u>");
    },
    _a[MarkType$1.STRIKE_THROUGH] = function (text) {
        return "<strike>".concat(text, "</strike>");
    },
    _a[MarkType$1.INLINE_CODE] = function (text) {
        return "<span>".concat(text, "</span>");
    },
    _a[MarkType$1.SUBSCRIPT] = function (text) {
        return "<sub>".concat(text, "</sub>");
    },
    _a[MarkType$1.SUPERSCRIPT] = function (text) {
        return "<sup>".concat(text, "</sup>");
    },
    _a);

function enumerate(entries, process) {
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var entry = entries_1[_i];
        process(entry);
    }
}
function enumerateContents(content, renderOption, renderEmbed) {
    if (!(content instanceof Array) && content.type !== 'doc') {
        return content;
    }
    if (content instanceof Array) {
        var result_1 = [];
        content.forEach(function (doc) {
            result_1.push(enumerateContents(doc, renderOption, renderEmbed));
        });
        return result_1;
    }
    var commonRenderOption = __assign(__assign({}, defaultNodeOption), renderOption);
    return nodeChildrenToHTML(content.children, commonRenderOption, renderEmbed);
}
function textNodeToHTML(node, renderOption) {
    var text = node.text;
    if (node.superscript) {
        text = renderOption[MarkType$1.SUPERSCRIPT](text);
    }
    if (node.subscript) {
        text = renderOption[MarkType$1.SUBSCRIPT](text);
    }
    if (node.inlineCode) {
        text = renderOption[MarkType$1.INLINE_CODE](text);
    }
    if (node.strikethrough) {
        text = renderOption[MarkType$1.STRIKE_THROUGH](text);
    }
    if (node.underline) {
        text = renderOption[MarkType$1.UNDERLINE](text);
    }
    if (node.italic) {
        text = renderOption[MarkType$1.ITALIC](text);
    }
    if (node.bold) {
        text = renderOption[MarkType$1.BOLD](text);
    }
    return text;
}
function referenceToHTML(node, renderOption, renderEmbed) {
    function sendToRenderOption(referenceNode) {
        return renderOption[referenceNode.type](referenceNode, undefined);
    }
    if (!renderEmbed && renderOption[node.type] !== undefined) {
        return sendToRenderOption(node);
    }
    if (!renderEmbed) {
        return '';
    }
    var metadata = nodeToMetadata(node.attrs, ((node.children && node.children.length > 0) ? node.children[0] : {}));
    var item = renderEmbed(metadata);
    if (!item && renderOption[node.type] !== undefined) {
        return sendToRenderOption(node);
    }
    return findRenderString(item, metadata, renderOption);
}
function nodeChildrenToHTML(nodes, renderOption, renderEmbed) {
    return nodes.map(function (node) { return nodeToHTML(node, renderOption, renderEmbed); }).join('');
}
function nodeToHTML(node, renderOption, renderEmbed) {
    if (!node.type) {
        return textNodeToHTML(node, renderOption);
    }
    else if (node.type === 'reference') {
        return referenceToHTML(node, renderOption, renderEmbed);
    }
    else {
        var next = function (nodes) { return nodeChildrenToHTML(nodes, renderOption, renderEmbed); };
        if (renderOption[node.type] !== undefined) {
            return renderOption[node.type](node, next);
        }
        else {
            return renderOption.default(node, next);
        }
    }
}

function jsonToHTML$1(option) {
    if (option.entry instanceof Array) {
        enumerate(option.entry, function (entry) {
            jsonToHTML$1({ entry: entry, paths: option.paths, renderOption: option.renderOption });
        });
    }
    else {
        enumerateKeys$1({
            entry: option.entry,
            paths: option.paths,
            renderOption: option.renderOption,
        });
    }
}
function enumerateKeys$1(option) {
    for (var _i = 0, _a = option.paths; _i < _a.length; _i++) {
        var key = _a[_i];
        findRenderContent(key, option.entry, (function (content) {
            return enumerateContents(content, option.renderOption, function (metadata) {
                return findEmbeddedItems(metadata, option.entry)[0];
            });
        }));
    }
}

function jsonToHTML(option) {
    if (option.entry instanceof Array) {
        enumerate(option.entry, function (entry) {
            jsonToHTML({ entry: entry, paths: option.paths, renderOption: option.renderOption });
        });
    }
    else {
        enumerateKeys({
            entry: option.entry,
            paths: option.paths,
            renderOption: option.renderOption,
        });
    }
}
function enumerateKeys(option) {
    for (var _i = 0, _a = option.paths; _i < _a.length; _i++) {
        var key = _a[_i];
        findRenderContent(key, option.entry, (function (content) {
            if (content && content.json) {
                var edges = content.embedded_itemsConnection ? content.embedded_itemsConnection.edges : [];
                var items_1 = Object.values(edges || []).reduce(function (accumulator, value) { return accumulator.concat(value.node); }, []);
                return enumerateContents(content.json, option.renderOption, function (metadata) {
                    return findGQLEmbeddedItems(metadata, items_1)[0];
                });
            }
            return content;
        }));
    }
}
var GQL = {
    jsonToHTML: jsonToHTML
};

function addTags(entry, contentTypeUid, tagsAsObject, locale) {
    if (locale === void 0) { locale = 'en-us'; }
    if (entry)
        entry.$ = getTag(entry, "".concat(contentTypeUid, ".").concat(entry.uid, ".").concat(locale), tagsAsObject, locale);
}
function getTag(content, prefix, tagsAsObject, locale) {
    var tags = {};
    Object.entries(content).forEach(function (_a) {
        var key = _a[0], value = _a[1];
        switch (typeof value) {
            case "object":
                if (Array.isArray(value)) {
                    value.forEach(function (obj, index) {
                        if (typeof obj !== 'undefined' && obj !== null && obj._content_type_uid !== undefined && obj.uid !== undefined) {
                            value[index].$ = getTag(obj, "".concat(obj._content_type_uid, ".").concat(obj.uid, ".").concat(obj.locale || locale), tagsAsObject, locale);
                        }
                        else {
                            if (typeof obj === "object") {
                                obj.$ = getTag(obj, "".concat(prefix, ".").concat(key, ".").concat(index), tagsAsObject, locale);
                            }
                            else {
                                tags[key] = getTagsValue("".concat(prefix, ".").concat(key), tagsAsObject);
                            }
                        }
                    });
                }
                else {
                    if (value) {
                        value.$ = getTag(value, "".concat(prefix, ".").concat(key), tagsAsObject, locale);
                    }
                }
                break;
            default:
                tags[key] = getTagsValue("".concat(prefix, ".").concat(key), tagsAsObject);
        }
    });
    return tags;
}
function getTagsValue(dataValue, tagsAsObject) {
    if (tagsAsObject) {
        return { "data-cslp": dataValue };
    }
    else {
        return "data-cslp=".concat(dataValue);
    }
}

exports.Document = Document;
exports.GQL = GQL;
exports.MarkType = MarkType$1;
exports.Node = Node;
exports.NodeType = NodeType$1;
exports.StyleType = StyleType$1;
exports.TextNode = TextNode;
exports.addEditableTags = addTags;
exports.attributeToString = attributeToString;
exports.jsonToHTML = jsonToHTML$1;
exports.render = render;
exports.renderContent = renderContent;
//# sourceMappingURL=index.es.js.map
